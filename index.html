o<!Doctype: HTML w/ Processing>

<html>

  <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <title>Processing Demo</title>
      <script type="text/javascript" src="js/processing.js"></script>
  </head>
  
  <body>
    <h1>Zero Art Prototypes2022</h1>
    <p>ADD DESCRIPTION HERE</p>
    
    <script type="text/processing">
    FragmentTree tree;
int slices;
float rotationChance;
float translationChance;
float shearChance;
float explode;
float explodePerLevel;
float phase;
boolean freeze;
int counter;
int numFrames;
float zoom;
float tx, ty, ax, ay, az;
float ttx, tty, ttz;
float sscale;
boolean gui;
PShader filter, genFilter, post;
color bkg;
PImage[] textures;
PGraphics generator;
int currentSlice;
void setup() {
  size(900, 900, P3D);
  smooth(16);
  noCursor();
  post=loadShader("vignette.glsl");
  explode=5.0;
  numFrames=2000;
  textures=new PImage[40];
  generator=createGraphics(750, 750,P3D);
  generator.smooth(16);
  generator.beginDraw();
  generator.background(255);
  generator.endDraw();
  init();
  bkg=color(random(255), random(255), 255);//255, 140, 11);
  textureMode(NORMAL);
}

void init() {
  filter=(random(100)<50)?(random(100)<50.0)?loadShader("mirrorx.glsl"):loadShader("mirrory.glsl"):(random(100)<50.0)?loadShader("mirrorxy.glsl"):loadShader("donothing.glsl");
 
  int seed=(int)random(111110);
  println(String.format("%08d", seed));
  randomSeed(seed);
  initialGeometry();
  translationChance=0.43;//random(1.0);
  rotationChance=0.43;//random(1.0- translationChance);
  shearChance=0.0;//random(1.0- translationChance-rotationChance);
  //stretchChance=1.0-translationChance-rotationChance-shearChance;
  slices=24;
  tree=new FragmentTree(initialGeometry());
  for (int r=0; r<slices; r++) {
    slice(r, color(89), color(0));
  }
  counter=0;
  zoom=1.0;
  tx=ty=ax=ay=az=0.0;
  freeze=false;
  gui=true;
 
  for (int i=0; i<40; i++) {
   
    textures[i]=getTexture();
  }
}

PImage getTexture(){
  generator.beginDraw();
    generator.background(0);
    generator.pushMatrix();
    generator.translate(generator.width/2, generator.height/2);
    generator.noStroke();
    generator.fill(255);
    float d=random(20, 100);
    float t=random(20, 100);
    float a=random(PI);
    generator.rotate(a);
    for (int j=-50; j<=50; j++) {
      generator.rect(j*(d+t)-0.5*d, -10000, d, 20000);
    }
    genFilter=(random(100)<50)?(random(100)<50.0)?loadShader("mirrorx.glsl"):loadShader("mirrory.glsl"):(random(100)<50.0)?loadShader("mirrorxy.glsl"):loadShader("donothing.glsl");
    generator.filter(genFilter);
    generator.popMatrix();
    generator.endDraw();
    return generator.get();
  
}

ArrayList<SliceMesh> initialGeometry() {
  Transform T=new Transform();
  T.addRotateY(QUARTER_PI);
  T.addRotateX(radians(35.264));
  ArrayList<SliceMesh> sliceMeshes=new ArrayList<SliceMesh>();
  SliceMesh sliceMesh;
  sliceMesh=new SliceMesh();
  sliceMesh.create(MeshDataFactory.createBoxWithCenterAndSize(0, 0, 0, 300, 300, 1200, color(0)));
  //T.apply(sliceMesh);
  sliceMeshes.add(sliceMesh);
  tree=new FragmentTree(sliceMeshes);
  return sliceMeshes;
}

void slice(int sliceCount, color col, color col2) {
  currentSlice=sliceCount;
  Transformation M;
  int trial=0;
  do {

    float sliceRoll=random(1.0);
    if (sliceRoll<translationChance) {
      M=sliceAndTranslate();
    } else if (sliceRoll<rotationChance+translationChance) {
      M=sliceAndRotate();
    } else  if (sliceRoll<rotationChance+translationChance+shearChance) {
      M=sliceAndShear();
    } else {
      M=sliceAndStretch();
    }
    trial++;
  } while (tree.minDistance(M.plane)<5 && trial<20);

  M.level=sliceCount;
  tree.split(M, col, col2);
}

void draw() {
  ortho();
  float phase=0.5-0.52*cos(radians(360.0/numFrames*counter));
  background(bkg);
  filter(post);
  translate(width/2+tx, height/2+ty);
  float bri=255;//(phase<0.0125)?sqrt(80.0*phase)*255:255;
  pointLight(bri,bri,bri, 1000, 0, 0);
  pointLight(bri,bri,bri, 0, -1000, 0);
  pointLight(bri,bri,bri, 0, 0, 1000);
  rotateZ(radians(180+az));
  rotateX(radians(ax));
  rotateY(radians(ay+map(constrain(counter-numFrames/2,0,numFrames/2), 0, numFrames/2, 0, 360)));
  //rotateY(-QUARTER_PI);
  //rotateX(radians(-35.264));
  scale(zoom);
  tree.setPhase((slices+1)*phase);
  float[] extents=tree.getExtents();
  ttx=0.95*ttx-0.025*(extents[0]+extents[3]);
  tty=0.95*tty-0.025*(extents[1]+extents[4]);
  ttz=0.95*ttz-0.025*(extents[2]+extents[5]);
  sscale=min(1.0, min(1000.0/(extents[3]-extents[0]), 1000.0/(extents[4]-extents[1]), 1000/(extents[5]-extents[2])));
  scale(sscale);
  translate(ttx, tty, ttz);
  strokeWeight(2.0/(zoom*sscale));
  stroke(0, 75);
  fill(random(255), random(255), 255);
  tree.draw(textures);
  filter(filter);
  if (!freeze) counter++;
  if (counter==numFrames) {
    init();
  }
  
}


void keyPressed() {
  if (key==' ') {
    freeze=!freeze;
    ax=0;
    ay=0;
    az=0;
  } else if (key=='n') {
    init();
  } else if (key=='f') {
    if (freeze) {
      counter=max(counter-5, 0);
    }
  } else if (key=='F') {

    if (freeze) {
      counter=min(counter+5, 1800);
    }
  } else if (key=='x') {
    if (freeze) {
      ax-=5;
      if (ax<=-180) ax+=360;
    }
  } else if (key=='X') {
    if (freeze) {
      ax+=5;
      if (ax>180) ax-=360;
    }
  } else if (key=='y') {
    if (freeze) {
      ay-=5;
      if (ay<=-180) ay+=360;
    }
  } else if (key=='Y') {
    if (freeze) {
      ay+=5;
      if (ay>180) ay-=360;
    }
  } else if (key=='z') {
    if (freeze) {
      az-=5;
      if (az<=-180) az+=360;
    }
  } else if (key=='Z') {
    if (freeze) {
      az+=5;
      if (az>180) az-=360;
    }
  } else if (key=='+') {
    zoom+=0.05;
  } else if (key=='-') {
    zoom-=0.05;
  } else if (key== CODED) {
    if (keyCode==UP) {
      ty-=10;
    } else if (keyCode==DOWN) {
      ty+=10;
    } else if (keyCode==RIGHT) {
      tx+=10;
    } else if (keyCode==LEFT) {
      tx-=10;
    }
  }
}

class FragmentTree {
  ArrayList<Fragment> roots;

  FragmentTree(SliceMesh mesh) {
    roots=new ArrayList<Fragment>();
    roots.add(new Fragment(mesh));
  }

  FragmentTree(ArrayList<SliceMesh> meshes) {
    roots=new ArrayList<Fragment>();
    for (SliceMesh mesh : meshes) {
      roots.add(new Fragment(mesh));
    }
  }

  FragmentTree(SliceMesh... meshes) {
    roots=new ArrayList<Fragment>();
    for (SliceMesh mesh : meshes) {
      roots.add(new Fragment(mesh));
    }
  }

  void split(Transformation M, color col, color col2) {
    for (Fragment root : roots) {
      root.split(M, col, col2);
    }
  }

  void setPhase(float f) {
    for (Fragment root : roots) {
      root.setPhase(f);
    }
  }

  float[] getExtents() {
    float[] extents=new float[]{1000000, 1000000, 1000000, -1000000, -1000000, -1000000};
    for (Fragment root : roots) {
      root.addExtents(extents);
    }
    return extents;
  }

  void draw() {
    for (Fragment root : roots) {
      root.draw();
    }
  }
  
   void draw(PImage[] textures) {
    for (Fragment root : roots) {
      root.draw(textures);
    }
  }

  float minDistance(Plane P) {
    float minDistance=1000000;
    for (Fragment root : roots) {
      minDistance=min(minDistance, root.minDistance(P));
    }
    return minDistance;
  }
}



class Fragment {
  Fragment parent;
  Fragment child1, child2;
  Transformation parentToChild;
  SliceMesh mesh;
  SliceMesh invTMesh;
  SliceMesh dynMesh;
  SliceMesh drawMesh;
  int level;

  Fragment(SliceMesh mesh) {
    this.mesh = mesh.copy();
    invTMesh = mesh.copy();
    dynMesh = mesh.copy();
    parentToChild = null;
    parent = null;
    child1 = null;
    child2 = null;
    level = 0;
  }

  Fragment(SliceMesh mesh, Fragment parent, Transformation parentToChild) {
    this.mesh = mesh.copy();
    dynMesh= mesh.copy();
    this.parentToChild = parentToChild;
    this.parent = parent;
    invTMesh = mesh.copy();
    Fragment p = this;
    do {
      if ( p.parentToChild!=null) {
        Transform T = p.parentToChild.getInverseTransform(1.0);
        T.apply(invTMesh);
      }
      p = p.parent;
    } while (p != null);
    level=parent.level+1;
  }

  void split(Transformation M, color col, color col2) {
    if ((child1 == null) && (child2 == null)) {
      SliceMesh split1=mesh.copy();
      SliceMesh split2=mesh.copy();
      split1.slice(M.plane, 0.0, col);
      split2.slice(M.plane.flip(), 0.0, col2);
      if (split1.vertices.size() > 0 && split1.isValid()) {
        child1 = new Fragment(split1, this, null);
      }
      if (split2.vertices.size() > 0 && split2.isValid()) {
        M.getTransform(1.0).apply(split2);
        child2 = new Fragment(split2, this, M);
      }
    } else {
      if (child1 != null) {
        child1.split(M, col, col2);
      }
      if (child2 != null) {
        child2.split(M, col2, col);
      }
    }
  }


  float minDistance(Plane P) {
    float minDistance=1000000;
    if (((child1 == null) && (child2 == null))) {//||f<=level) {
      for (Vertex v : mesh.vertices) {
        minDistance=min(minDistance, v.distance(P));
        if(minDistance<5.0) return minDistance;
      }
    } else {
      if (child1 != null) {
         minDistance=min(minDistance, child1.minDistance(P));
      }
      if (child2 != null) {
         minDistance=min(minDistance,  child2.minDistance(P));
      }
    }
    return minDistance;
  }

  void setPhase(float f) {
    if (((child1 == null) && (child2 == null))||f<=level) {
      drawMesh = getMesh(f);
    } else {
      drawMesh=null;
      if (child1 != null) {
        child1.setPhase(f);
      }
      if (child2 != null) {
        child2.setPhase(f);
      }
    }
  }

  void addExtents(float[] extents) {
    if (drawMesh!=null) {
      float[] fragmentExtents=drawMesh.getExtents();
      for (int i=0; i<3; i++) {
        extents[i]=min(extents[i], fragmentExtents[i]);
        extents[i+3]=max(extents[i+3], fragmentExtents[i+3]);
      }
    } else {
      if (child1 != null) {
        child1.addExtents(extents);
      }
      if (child2 != null) {
        child2.addExtents(extents);
      }
    }
  }


  void draw() {
    if (drawMesh!=null) {
      drawMesh.draw();
    } else {
      if (child1 != null) {
        child1.draw();
      }
      if (child2 != null) {
        child2.draw();
      }
    }
  }
  
  void draw(PImage[] textures) {
    if (drawMesh!=null) {
      drawMesh.draw(textures);
    } else {
      if (child1 != null) {
        child1.draw(textures);
      }
      if (child2 != null) {
        child2.draw(textures);
      }
    }
  }

  SliceMesh getMesh(float f) {
    if (f<=0) {   
      return invTMesh;
    } else if (f>=level) {   
      return mesh;
    } else {
      Fragment p = this;
      float fracf;
      Transform T=new Transform();
      do {
        if (p.parentToChild!=null) {
          fracf=constrain((float)(p.level-f), 0.0, 1.0);
          T.addTransform(p.parentToChild.getInverseTransform(fracf));
        }
        p = p.parent;
      } while (p != null && f<p.level);
      T.apply(mesh, dynMesh);
      return dynMesh;
    }
  }
}

float EPS=0.0001;
float OMEPS=0.9999;
float OPEPS=1.0001;

class Plane {
  PVector origin;
  PVector normal;
  PVector u, v;

  Plane(PVector origin, PVector normal) {
    this.origin=origin.copy();
    this.normal=normal.copy();
    this.normal.normalize();
    u=new PVector(0, 0, 1).cross(normal);
    if (sqrt(u.dot(u))<EPS) {
      u=new PVector(0, 1, 0).cross(normal);
    }
    u.normalize();
    v=normal.cross(u);
  }


  Plane offset(float d) {
    return new Plane(PVector.add(origin, PVector.mult(normal, d)), normal);
  }

  Plane flip() {
    return new Plane(origin, PVector.mult(normal, -1));
  }
  
  PVector local(float x, float y, float z){
    return new PVector(
        u.x * (x - origin.x) + u.y * (y - origin.y) + u.z * (z - origin.z),
        v.x * (x - origin.x) + v.y * (y - origin.y) + v.z * (z - origin.z),
        normal.x * (x - origin.x) + normal.y * (y - origin.y) + normal.z * (z - origin.z));
  }
  
  void draw(float side) {
    beginShape();
    vertex(origin.x-0.5*side*u.x-0.5*side*v.x, origin.y-0.5*side*u.y-0.5*side*v.y, origin.z-0.5*side*u.z-0.5*side*v.z);
    vertex(origin.x+0.5*side*u.x-0.5*side*v.x, origin.y+0.5*side*u.y-0.5*side*v.y, origin.z+0.5*side*u.z-+0.5*side*v.z);
    vertex(origin.x+0.5*side*u.x+0.5*side*v.x, origin.y+0.5*side*u.y+0.5*side*v.y, origin.z+0.5*side*u.z+0.5*side*v.z);
    vertex(origin.x-0.5*side*u.x+0.5*side*v.x, origin.y-0.5*side*u.y+0.5*side*v.y, origin.z-0.5*side*u.z+0.5*side*v.z);
    endShape();
  }
}

class Transform {
  float _xt, _yt, _zt, _wt;
  M44 T;
  M44 invT;

  Transform() {
    T = new M44(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    invT = new M44(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  }

  Transform(Transform Trans) {
    T = Trans.T.get();
    invT = Trans.invT.get();
  }

  Transform addTransform(Transform transform) {
    T = transform.T.mul(T);
    invT = invT.mul(transform.invT);
    return this;
  }

  Transform addTranslate(PVector v) {
    T = new M44(1, 0, 0, v.x, 0, 1, 0, v.y, 0, 0, 1, v.z, 0, 0, 0, 1).mul(T);
    invT = invT.mul(new M44(1, 0, 0, -v.x, 0, 1, 0, -v.y, 0, 0, 1, -v.z, 0, 0, 0, 1));
    return this;
  }

  Transform addTranslate(float f, PVector v) {
    T = new M44(1, 0, 0, f * v.x, 0, 1, 0, f * v.y, 0, 0, 1, f * v.z, 0, 0, 0, 1).mul(T);
    invT = invT.mul(new M44(1, 0, 0, -f * v.x, 0, 1, 0, -f * v.y, 0, 0, 1, -f * v.z, 0, 0, 0, 1));
    return this;
  }

  Transform addScale(PVector s) {
    T = new M44(s.x, 0, 0, 0, 0, s.y, 0, 0, 0, 0, s.z, 0, 0, 0, 0, 1).mul(T);
    invT = invT.mul(new M44(1.0 / s.x, 0, 0, 0, 0, 1.0 / s.y, 0, 0, 0, 0, 1.0 / s.z, 0, 0, 0, 0, 1));
    return this;
  }

  Transform addScale(float sx, float sy, float sz) {
    T = new M44(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1).mul(T);
    invT = invT.mul(new M44(1.0 / sx, 0, 0, 0, 0, 1.0 / sy, 0, 0, 0, 0, 1.0 / sz, 0, 0, 0, 0, 1));
    return this;
  }

  Transform addScale(float s) {
    T = new M44(s, 0, 0, 0, 0, s, 0, 0, 0, 0, s, 0, 0, 0, 0, 1).mul(T);
    invT = invT.mul(new M44(1 / s, 0, 0, 0, 0, 1 / s, 0, 0, 0, 0, 1 / s, 0, 0, 0, 0, 1));
    return this;
  }

  Transform addRotateX(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    M44 tmp = new M44(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    T = tmp.mul(T);
    invT = invT.mul(tmp.getTranspose());
    return this;
  }

  Transform addRotateY(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    M44 tmp = new M44(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    T = tmp.mul(T);
    invT = invT.mul(tmp.getTranspose());
    return this;
  }

  Transform addRotateZ(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    M44 tmp = new M44(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    T = tmp.mul(T);
    invT = invT.mul(tmp.getTranspose());
    return this;
  }

  Transform addRotateAboutOrigin(float angle, PVector axis) {
    PVector a = new PVector(axis.x, axis.y, axis.z);
    a.normalize();
    float s = sin(angle);
    float c = cos(angle);
    M44 tmp = new M44(a.x * a.x + (1.f - a.x * a.x) * c, 
      a.x * a.y * (1.f - c) - a.z * s, a.x * a.z * (1.f - c) + a.y * s, 0, 
      a.x * a.y * (1.f - c) + a.z * s, a.y * a.y + (1.f - a.y * a.y) * c, 
      a.y * a.z * (1.f - c) - a.x * s, 0, a.x * a.z * (1.f - c) - a.y * s, 
      a.y * a.z * (1.f - c) + a.x * s, a.z * a.z + (1.f - a.z * a.z) * c, 0, 0, 0, 0, 1);
    T = tmp.mul(T);
    invT = invT.mul(tmp.getTranspose());
    return this;
  }

  Transform addRotateAboutAxis(float angle, PVector p, PVector axis) {
    addTranslate(-1, p);
    addRotateAboutOrigin(angle, axis);
    addTranslate(p);
    return this;
  }

  Transform addRotateAboutAxis2P(float angle, PVector p, PVector q) {
    addTranslate(-1, p);
    addRotateAboutOrigin(angle, PVector.sub(q, p));
    addTranslate(p);
    return this;
  }

  Transform addShear(PVector origin, PVector normal, PVector v, float angle) {
    addTranslate(-1, origin);
    PVector lv = new PVector(v.x, v.y, v.z);
    lv.normalize();
    float tana = tan(angle);
    lv.mult(tana);
    M33 tmp = M33.tensor(lv.x, lv.y, lv.z, normal.x, normal.y, normal.z);
    M44 Tr = new M44(1 + tmp.m11, tmp.m12, tmp.m13, 0, tmp.m21, 1 + tmp.m22, tmp.m23, 0, tmp.m31, tmp.m32, 
      1 + tmp.m33, 0, 0, 0, 0, 1);
    T = Tr.mul(T);
    tana *= -1;
    Tr = new M44(1 - tmp.m11, -tmp.m12, -tmp.m13, 0, -tmp.m21, 1 - tmp.m22, -tmp.m23, 0, -tmp.m31, -tmp.m32, 
      1 - tmp.m33, 0, 0, 0, 0, 1);
    invT = invT.mul(Tr);
    addTranslate(origin);
    return this;
  }

  Transform addStretch(PVector origin, PVector axis, float factor) {
    Plane P=new Plane(origin, axis);
    addFromWorldToCS(P.origin, P.u, P.v, P.normal);
    float invsqrt = 1.0 / sqrt(abs(factor));
    addScale(invsqrt, invsqrt, factor);
    addFromCSToWorld(P.origin, P.u, P.v, P.normal);
    return this;
  }

  Transform addFromCSToWorld(PVector origin, PVector X, PVector Y, PVector Z) {
    PVector ex2 = new PVector(1, 0, 0), ey2 = new PVector(0, 1, 0), ez2 =new PVector(0, 0, 1);
    PVector o2 = new PVector(0, 0, 0);
    float xx = ex2.dot(X);
    float xy = ex2.dot(Y);
    float xz = ex2.dot(Z);
    float yx = ey2.dot(X);
    float yy = ey2.dot(Y);
    float yz = ey2.dot(Z);
    float zx = ez2.dot(X);
    float zy = ez2.dot(Y);
    float zz = ez2.dot(Z);
    M44 tmp = new M44(xx, xy, xz, 0, yx, yy, yz, 0, zx, zy, zz, 0, 0, 0, 0, 1);
    M44 invtmp = new M44(xx, yx, zx, 0, xy, yy, zy, 0, xz, yz, zz, 0, 0, 0, 0, 1);
    T = tmp.mul(T);
    invT = invT.mul(invtmp);
    addTranslate(origin);
    return this;
  }

  Transform addFromWorldToCS(PVector origin, PVector X, PVector Y, PVector Z) {
    Transform tmp=new Transform();
    tmp.addFromCSToWorld(origin, X, Y, Z);
    T = tmp.invT.mul(T);
    invT = invT.mul(tmp.T);
    return this;
  }

  void inverse() {
    M44 tmp;
    tmp = T;
    T = invT;
    invT = tmp;
  }

  void clear() {
    T = new M44(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    invT = new M44(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  }

  void apply(Mesh mesh) {
    for (Vertex p : mesh.vertices) {
      _xt = T.m11 * p.x + T.m12 * p.y + T.m13 * p.z + T.m14;
      _yt = T.m21 * p.x + T.m22 * p.y + T.m23 * p.z + T.m24;
      _zt = T.m31 * p.x + T.m32 * p.y + T.m33 * p.z + T.m34;
      _wt = T.m41 * p.x + T.m42 * p.y + T.m43 * p.z + T.m44;
      _wt = 1.0 / _wt;
      p.x=_xt * _wt;
      p.y=_yt * _wt;
      p.z= _zt * _wt;
    }
  }

  void apply(Mesh mesh, Mesh target) {
    Vertex p, q;
    for (int i=0; i<mesh.vertices.size(); i++) {
      p=mesh.vertices.get(i);
      _xt = T.m11 * p.x + T.m12 * p.y + T.m13 * p.z + T.m14;
      _yt = T.m21 * p.x + T.m22 * p.y + T.m23 * p.z + T.m24;
      _zt = T.m31 * p.x + T.m32 * p.y + T.m33 * p.z + T.m34;
      _wt = T.m41 * p.x + T.m42 * p.y + T.m43 * p.z + T.m44;
      _wt = 1.0 / _wt;
      q=target.vertices.get(i);
      q.x=_xt * _wt;
      q.y=_yt * _wt;
      q.z= _zt * _wt;
    }
  }

  void applyInv(Mesh mesh) {
    for (Vertex p : mesh.vertices) {
      _xt = invT.m11 * p.x + invT.m12 * p.y + invT.m13 * p.z + invT.m14;
      _yt = invT.m21 * p.x + invT.m22 * p.y + invT.m23 * p.z + invT.m24;
      _zt = invT.m31 * p.x + invT.m32 * p.y + invT.m33 * p.z + invT.m34;
      _wt = invT.m41 * p.x + invT.m42 * p.y + invT.m43 * p.z + invT.m44;
      _wt = 1.0 / _wt;
      p.x=_xt * _wt;
      p.y=_yt * _wt;
      p.z= _zt * _wt;
    }
  }
}

static class M44 {
  float m11, m12, m13, m14;
  float m21, m22, m23, m24;
  float m31, m32, m33, m34;
  float m41, m42, m43, m44;

  M44() {
  }

  M44(float[][] matrix44) {
    m11 = matrix44[0][0];
    m12 = matrix44[0][1];
    m13 = matrix44[0][2];
    m14 = matrix44[0][3];
    m21 = matrix44[1][0];
    m22 = matrix44[1][1];
    m23 = matrix44[1][2];
    m24 = matrix44[1][3];
    m31 = matrix44[2][0];
    m32 = matrix44[2][1];
    m33 = matrix44[2][2];
    m34 = matrix44[2][3];
    m41 = matrix44[3][0];
    m42 = matrix44[3][1];
    m43 = matrix44[3][2];
    m44 = matrix44[3][3];
  }

  M44(float m11, float m12, float m13, float m14, float m21, 
    float m22, float m23, float m24, float m31, float m32, float m33, 
    float m34, float m41, float m42, float m43, float m44) {
    this.m11 = m11;
    this.m12 = m12;
    this.m13 = m13;
    this.m14 = m14;
    this.m21 = m21;
    this.m22 = m22;
    this.m23 = m23;
    this.m24 = m24;
    this.m31 = m31;
    this.m32 = m32;
    this.m33 = m33;
    this.m34 = m34;
    this.m41 = m41;
    this.m42 = m42;
    this.m43 = m43;
    this.m44 = m44;
  }

  void set(float[][] matrix44) {
    m11 = matrix44[0][0];
    m12 = matrix44[0][1];
    m13 = matrix44[0][2];
    m14 = matrix44[0][3];
    m21 = matrix44[1][0];
    m22 = matrix44[1][1];
    m23 = matrix44[1][2];
    m24 = matrix44[1][3];
    m31 = matrix44[2][0];
    m32 = matrix44[2][1];
    m33 = matrix44[2][2];
    m34 = matrix44[2][3];
    m41 = matrix44[3][0];
    m42 = matrix44[3][1];
    m43 = matrix44[3][2];
    m44 = matrix44[3][3];
  }

  void set(float m11, float m12, float m13, float m14, float m21, 
    float m22, float m23, float m24, float m31, float m32, float m33, 
    float m34, float m41, float m42, float m43, float m44) {
    this.m11 = m11;
    this.m12 = m12;
    this.m13 = m13;
    this.m14 = m14;
    this.m21 = m21;
    this.m22 = m22;
    this.m23 = m23;
    this.m24 = m24;
    this.m31 = m31;
    this.m32 = m32;
    this.m33 = m33;
    this.m34 = m34;
    this.m41 = m41;
    this.m42 = m42;
    this.m43 = m43;
    this.m44 = m44;
  }

  M44 get() {
    return new M44(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44);
  }

  M44 mul(M44 m) {
    return new M44(m11 * m.m11 + m12 * m.m21 + m13 * m.m31 + m14 * m.m41, 
      m11 * m.m12 + m12 * m.m22 + m13 * m.m32 + m14 * m.m42, 
      m11 * m.m13 + m12 * m.m23 + m13 * m.m33 + m14 * m.m43, 
      m11 * m.m14 + m12 * m.m24 + m13 * m.m34 + m14 * m.m44, 
      m21 * m.m11 + m22 * m.m21 + m23 * m.m31 + m24 * m.m41, 
      m21 * m.m12 + m22 * m.m22 + m23 * m.m32 + m24 * m.m42, 
      m21 * m.m13 + m22 * m.m23 + m23 * m.m33 + m24 * m.m43, 
      m21 * m.m14 + m22 * m.m24 + m23 * m.m34 + m24 * m.m44, 
      m31 * m.m11 + m32 * m.m21 + m33 * m.m31 + m34 * m.m41, 
      m31 * m.m12 + m32 * m.m22 + m33 * m.m32 + m34 * m.m42, 
      m31 * m.m13 + m32 * m.m23 + m33 * m.m33 + m34 * m.m43, 
      m31 * m.m14 + m32 * m.m24 + m33 * m.m34 + m34 * m.m44, 
      m41 * m.m11 + m42 * m.m21 + m43 * m.m31 + m44 * m.m41, 
      m41 * m.m12 + m42 * m.m22 + m43 * m.m32 + m44 * m.m42, 
      m41 * m.m13 + m42 * m.m23 + m43 * m.m33 + m44 * m.m43, 
      m41 * m.m14 + m42 * m.m24 + m43 * m.m34 + m44 * m.m44);
  }

  M44 inverse() {
    float[][] m = new float[][] { { m11, m12, m13, m14 }, { m21, m22, m23, m24 }, { m31, m32, m33, m34 }, 
      { m41, m12, m43, m44 } };
    int[] indxc = new int[4];
    int[] indxr = new int[4];
    int[] ipiv = new int[4];
    float[][] minv = new float[4][4];
    for (int i = 0; i < 4; i++) {
      for (int j = 0; j < 4; j++) {
        minv[i][j] = m[i][j];
      }
    }
    for (int i = 0; i < 4; i++) {
      int irow = -1, icol = -1;
      float big = 0.;
      // Choose pivot
      for (int j = 0; j < 4; j++) {
        if (ipiv[j] != 1) {
          for (int k = 0; k < 4; k++) {
            if (ipiv[k] == 0) {
              if (abs(minv[j][k]) >= big) {
                big = abs(minv[j][k]);
                irow = j;
                icol = k;
              }
            } else if (ipiv[k] > 1) {
              return null;
            }
          }
        }
      }
      ++ipiv[icol];
      // Swap rows _irow_ and _icol_ for pivot
      float tmp;
      if (irow != icol) {
        for (int k = 0; k < 4; ++k) {
          tmp = minv[irow][k];
          minv[irow][k] = minv[icol][k];
          minv[icol][k] = tmp;
        }
      }
      indxr[i] = irow;
      indxc[i] = icol;
      if (minv[icol][icol] == 0.) {
        return null;
      }
      // Set $m[icol][icol]$ to one by scaling row _icol_ appropriately
      float pivinv = 1.0 / minv[icol][icol];
      minv[icol][icol] = 1.0;
      for (int j = 0; j < 4; j++) {
        minv[icol][j] *= pivinv;
      }
      // Subtract this row from others to zero out their columns
      for (int j = 0; j < 4; j++) {
        if (j != icol) {
          float save = minv[j][icol];
          minv[j][icol] = 0;
          for (int k = 0; k < 4; k++) {
            minv[j][k] -= minv[icol][k] * save;
          }
        }
      }
    }
    float tmp;
    // Swap columns to reflect permutation
    for (int j = 3; j >= 0; j--) {
      if (indxr[j] != indxc[j]) {
        for (int k = 0; k < 4; k++) {
          tmp = minv[k][indxr[j]];
          minv[k][indxr[j]] = minv[k][indxc[j]];
          minv[k][indxc[j]] = tmp;
        }
      }
    }
    M44 I = new M44(minv);
    return I;
  }

  void transpose() {
    float tmp = m12;
    m12 = m21;
    m21 = tmp;
    tmp = m13;
    m13 = m31;
    m31 = tmp;
    tmp = m14;
    m14 = m41;
    m41 = tmp;
    tmp = m23;
    m23 = m32;
    m32 = tmp;
    tmp = m24;
    m24 = m42;
    m42 = tmp;
    tmp = m34;
    m34 = m43;
    m43 = tmp;
  }

  M44 getTranspose() {
    return new M44(m11, m21, m31, m41, m12, m22, m32, m42, m13, m23, m33, m43, m14, m24, m34, m44);
  }
}

static class M33 {
  float m11, m12, m13;
  float m21, m22, m23;
  float m31, m32, m33;

  M33() {
  }

  M33(float[][] matrix33) {
    m11 = matrix33[0][0];
    m12 = matrix33[0][1];
    m13 = matrix33[0][2];
    m21 = matrix33[1][0];
    m22 = matrix33[1][1];
    m23 = matrix33[1][2];
    m31 = matrix33[2][0];
    m32 = matrix33[2][1];
    m33 = matrix33[2][2];
  }

  M33(float m11, float m12, float m13, float m21, float m22, 
    float m23, float m31, float m32, float m33) {
    this.m11 = m11;
    this.m12 = m12;
    this.m13 = m13;
    this.m21 = m21;
    this.m22 = m22;
    this.m23 = m23;
    this.m31 = m31;
    this.m32 = m32;
    this.m33 = m33;
  }

  void set(float m11, float m12, float m13, float m21, float m22, 
    float m23, float m31, float m32, float m33) {
    this.m11 = m11;
    this.m12 = m12;
    this.m13 = m13;
    this.m21 = m21;
    this.m22 = m22;
    this.m23 = m23;
    this.m31 = m31;
    this.m32 = m32;
    this.m33 = m33;
  }

  void set(M33 m) {
    m11 = m.m11;
    m12 = m.m12;
    m13 = m.m13;
    m21 = m.m21;
    m22 = m.m22;
    m23 = m.m23;
    m31 = m.m31;
    m32 = m.m32;
    m33 = m.m33;
  }

  M33 get() {
    return new M33(m11, m12, m13, m21, m22, m23, m31, m32, m33);
  }

  static M33 tensor(float ux, float uy, float uz, float vx, 
    float vy, float vz) {
    return new M33( ux * vx, ux * vy, ux * vz, uy * vx, uy * vy, uy * vz, 
      uz * vx, uz * vy, uz * vz);
  }

  void div(float f) {
    float invf = 1.0 / f;
    m11 *= invf;
    m12 *= invf;
    m13 *= invf;
    m21 *= invf;
    m22 *= invf;
    m23 *= invf;
    m31 *= invf;
    m32 *= invf;
    m33 *= invf;
  }

  M33 mul(M33 n) {
    return new M33(m11 * n.m11 + m12 * n.m21 + m13 * n.m31, m11 * n.m12 + m12 * n.m22 + m13 * n.m32, 
      m11 * n.m13 + m12 * n.m23 + m13 * n.m33, m21 * n.m11 + m22 * n.m21 + m23 * n.m31, 
      m21 * n.m12 + m22 * n.m22 + m23 * n.m32, m21 * n.m13 + m22 * n.m23 + m23 * n.m33, 
      m31 * n.m11 + m32 * n.m21 + m33 * n.m31, m31 * n.m12 + m32 * n.m22 + m33 * n.m32, 
      m31 * n.m13 + m32 * n.m23 + m33 * n.m33);
  }

  float det() {
    return m11 * (m22 * m33 - m23 * m32) + m12 * (m23 * m31 - m21 * m33) + m13 * (m21 * m32 - m22 * m31);
  }

  void transpose() {
    float tmp = m12;
    m12 = m21;
    m21 = tmp;
    tmp = m13;
    m13 = m31;
    m31 = tmp;
    tmp = m23;
    m23 = m32;
    m32 = tmp;
  }

  M33 getTranspose() {
    return new M33(m11, m21, m31, m12, m22, m32, m13, m23, m33);
  }

  M33 inverse() {
    float d = det();
    if (abs(d)<0.000001) {
      return null;
    }
    M33 I = new M33(m22 * m33 - m23 * m32, m13 * m32 - m12 * m33, m12 * m23 - m13 * m22, 
      m23 * m31 - m21 * m33, m11 * m33 - m13 * m31, m13 * m21 - m11 * m23, m21 * m32 - m22 * m31, 
      m12 * m31 - m11 * m32, m11 * m22 - m12 * m21);
    I.div(d);
    return I;
  }

    String toString() {
    return "M33: " + m11 + ", " + m12 + ", " + m13 + ", " + m21 + ", " + m22 + ", " + m23 + ", " + m31 + ", " + m32
      + ", " + m33;
  }
}

class Halfedge {
  Halfedge pair;
  Halfedge next;
  Halfedge prev;
  Vertex v;
  Face f;
  Edge e;
  int index;
  PVector UV;

  Halfedge(int i) {
    index=i;
    UV=new PVector();
  }

  Halfedge nextInVertex() {
    return pair.next;
  }

  Halfedge prevInVertex() {
    return prev.pair;
  }
}

class Vertex {
  float x, y, z;
  Halfedge he;  
  int index;
  Vertex(float x, float y, float z, int i) {
    this.x=x;
    this.y=y;
    this.z=z;
    this.index=i;
  }

  float distance(Plane P) {
    float signedDistance = P.normal.dot(new PVector(x-P.origin.x, y- P.origin.y, z-P.origin.z));
    return abs(signedDistance);
  }

  int sideOfPlane(Plane P) {
    float signedDistance = P.normal.dot(new PVector(x-P.origin.x, y- P.origin.y, z-P.origin.z));
    return (signedDistance>EPS)?1:(signedDistance<-EPS)?-1:0;
  }
}

class Face {
  Halfedge he; 
  int index;
  color col;
  int textureId;
  Face(int i, color col) {
    index=i;
    this.col=col;
    textureId=0;
  }

  int order() {
    Halfedge lhe=he;
    int order=0;
    do {
      order++;
      lhe=lhe.next;
    } while (lhe!=he);
    return order;
  }

  int sideOfPlane(Plane P) {
    Halfedge lhe=he;
    int sideOfVertex;
    int plus=0;
    int minus=0;
    do {
      sideOfVertex = lhe.v.sideOfPlane(P);
      if (sideOfVertex==1) { 
        plus++;
      } else  if (sideOfVertex==-1) { 
        minus++;
      }
      lhe=lhe.next;
    } while (lhe!=he);
    if (plus>0 && minus==0) {
      return 1;
    } else if (plus==0 && minus>0) {
      return -1;
    } else {
      return 0;
    }
  }
}

class Edge {
  Halfedge he;
  int index;
  Edge(int i) {
    index=i;
  }
}

class Mesh {
  ArrayList<Halfedge> halfedges;
  ArrayList<Vertex> vertices;
  ArrayList<Face> faces;
  ArrayList<Edge> edges;



  Mesh() {
    initialize();
  }

  void initialize() {
    halfedges=new ArrayList<Halfedge>(); 
    vertices=new ArrayList<Vertex>();
    faces=new ArrayList<Face>();
    edges=new ArrayList<Edge>();
  }

  void create(MeshData data) {
    createRaw(data.vertexArray, data.faceArray, data.halfedgePairArray, data.faceColor);
    if(data.faceTextureIds!=null)setFaceTextureIds(data.faceTextureIds);
   if(data.UVs!=null)setUVs(data.UVs);
  }

  void createRaw(float[][] vertexArray, int[][] faceArray, int[] halfedgePairArray, color[] col) {
    initialize();
    for (float[] vertex : vertexArray) {
      createVertex(vertex);
    }
    int i=0;
    for (int[] face : faceArray) {
      createFace(face, col[i++]);
    }
    createEdges(halfedgePairArray);
  }



  Mesh copy() {
    Mesh copy=new Mesh();
    copy.createRaw(copyVertexArray(), copyFaceArray(), copyHalfedgePairArray(), copyFaceColor());
    copy.setFaceTextureIds(copyFaceTextureIds());
    copy.setUVs(copyUVs());
    return copy;
  }

  float[][] copyVertexArray() {
    float[][] copy =new float[vertices.size()][3];
    int index=0;  
    for (Vertex v : vertices) {
      copy[index][0]=v.x;
      copy[index][1]=v.y;
      copy[index][2]=v.z;
      index++;
    }
    return copy;
  }

  int[][] copyFaceArray() {
    int[][] copy =new int[faces.size()][];
    int index=0;
    int order, hei;
    Halfedge he;
    for (Face f : faces) {
      order=f.order();
      copy[index]=new int[order];
      hei=0;
      he=f.he;
      do {
        copy[index][hei++]=he.v.index;
        he=he.next;
      } while (he!=f.he);
      index++;
    }
    return copy;
  }

  color[] copyFaceColor() {
    color[] copy =new color[faces.size()];
    int index=0;

    for (Face f : faces) {

      copy[index]=f.col;

      index++;
    }
    return copy;
  }

  int[] copyFaceTextureIds() {
    int[] copy =new int[faces.size()];
    int index=0;
    for (Face f : faces) {
      copy[index]=f.textureId;
      index++;
    }
    return copy;
  }


  int[] copyHalfedgePairArray() {
    int[] oldtonew =new int[halfedges.size()];
    int[] newtoold =new int[halfedges.size()];
    int[] copy =new int[halfedges.size()];
    int index=0;
    Halfedge he;
    for (Face f : faces) {
      he=f.he;
      do {
        oldtonew[he.index]=index;
        newtoold[index]=he.index;
        index++;
        he=he.next;
      } while (he!=f.he);
    }

    for (int i=0; i<halfedges.size(); i++) {
      copy[i]=oldtonew[halfedges.get(newtoold[i]).pair.index];
    }
    return copy;
  }


  float[][] copyUVs() {
    int[] oldtonew =new int[halfedges.size()];
    int[] newtoold =new int[halfedges.size()];
    float[][] copy =new float[halfedges.size()][2];
    int index=0;
    Halfedge he;
    for (Face f : faces) {
      he=f.he;
      do {
        oldtonew[he.index]=index;
        newtoold[index]=he.index;
        index++;
        he=he.next;
      } while (he!=f.he);
    }
    PVector UV;
    for (int i=0; i<halfedges.size(); i++) {
      UV=halfedges.get(newtoold[i]).UV;
        copy[i]=new float[]{UV.x, UV.y};
    }
    return copy;
  }

  void createVertex(float... vertex) {
    vertices.add(new Vertex(vertex[0], vertex[1], vertex[2], vertices.size()));
  }

  void createFace(int[] face, color col) {
    Face f=new Face(faces.size(), col);
    faces.add(f);
    Vertex v;
    Halfedge he;
    ArrayList<Halfedge> faceHalfedges=new ArrayList<Halfedge>(); 
    for (int i=0; i<face.length; i++) {
      v=vertices.get(face[i]);
      he=new Halfedge(halfedges.size());
      halfedges.add(he);
      faceHalfedges.add(he);
      connectVertex(v, he);
      connectFace(f, he);
    }
    for (int i=0, j=faceHalfedges.size()-1; i<faceHalfedges.size(); j=i, i++) {
      connectHalfedges(faceHalfedges.get(j), faceHalfedges.get(i));
    }
  }

  void createEdges(int[] halfedgePairArray) {
    for (Halfedge he : halfedges) {
      int pairIndex=halfedgePairArray[he.index];
      if (he.pair==null) {
        pairHalfedges(he, halfedges.get(pairIndex));
        createEdge(he);
      } else {
        assert (he.pair.index==pairIndex);
      }
    }
  }

  void pairHalfedges(Halfedge he1, Halfedge he2) {
    he1.pair=he2;
    he2.pair=he1;
  }

  void createEdge(Halfedge he) {
    Edge e=new Edge(edges.size());
    connectEdge(e, he);
    edges.add(e);
  }

  void connectHalfedges(Halfedge he1, Halfedge he2) {
    he1.next=he2;
    he2.prev=he1;
  }

  void connectVertex(Vertex v, Halfedge he) {
    if (v.he==null) v.he=he; 
    he.v=v;
  }

  void connectFace(Face f, Halfedge he) {
    if (f.he==null) f.he=he; 
    he.f=f;
  }

  void connectEdge(Edge e, Halfedge he) {
    if (e.he==null) e.he=he; 
    he.e=e;
    he.pair.e=e;
  }

  void draw() {
    Halfedge he;
    for (Face f : faces) {
      fill(f.col);
      beginShape();
      he=f.he;
      do {
        vertex(he.v.x, he.v.y, he.v.z);
        he=he.next;
      } while (he!=f.he);
      endShape(CLOSE);
    }
  }

  void draw(PImage... textures) {
    Halfedge he;
    for (Face f : faces) {
 
      beginShape();
       texture(textures[f.textureId]);
      he=f.he;
      do {

        vertex(he.v.x, he.v.y, he.v.z, he.UV.x, he.UV.y);
        he=he.next;
      } while (he!=f.he);
      endShape(CLOSE);
    }
  }

  void indexVertices() {
    int index=0;
    for (Vertex v : vertices) {
      v.index=index++;
    }
  }

  void indexHalfedges() {
    int index=0;
    for (Halfedge he : halfedges) {
      he.index=index++;
    }
  }

  void indexEdges() {
    int index=0;
    for (Edge e : edges) {
      e.index=index++;
    }
  }

  void indexFaces() {
    int index=0;
    for (Face f : faces) {
      f.index=index++;
    }
  }

  void reconnectVertices() {
    int index=0;
    for (Halfedge he : halfedges) {
      if (he.v.he==null) he.v.he=he;
    }
  }

  boolean isValid() {
    for (Halfedge he : halfedges) {
      if (he.v==null) return false; 
      if (he.pair==null) return false;
      if (he.pair.pair==null) return false;
      if (he.pair.pair!=he) return false;
      if (he.f==null) return false;
      if (he.next==null) return false;
      if (he.next.prev==null) return false;
      if (he.next.prev!=he) return false;
      if (he.prev==null) return false;
      if (he.prev.next==null) return false;
      if (he.prev.next!=he) return false;
    }
    return true; //maybe
  }

  void triangulate() {
    int numberOfTriangles=0;
    int[][] faces=copyFaceArray();
    color[] colors=copyFaceColor();
    for (int[] face : faces) {
      numberOfTriangles+=face.length-2;
    }
    int[][] triFaces=new int[numberOfTriangles][];
    color[] triColors=new color[numberOfTriangles];
    int index=0;
    int fc=0;
    for (int[] face : faces) {
      for (int i=1; i<face.length-1; i++) {
        triFaces[index]=new int[]{face[0], face[i], face[i+1]};
        triColors[index]=colors[fc];
        index++;
      }
      fc++;
    }
    create(MeshDataFactory.create(copyVertexArray(), triFaces, triColors));
  }

  void save(String path) {
    Mesh copy=copy();
    copy.triangulate();
    PrintWriter out=createWriter(path);
    for (Vertex v : copy.vertices) {
      out.println("v "+v.x+" "+v.y+" "+v.z);
    }
    Halfedge he;
    for (Face f : copy.faces) {
      out.print("f");
      he=f.he;
      do {
        out.print(" "+(he.v.index+1));
        he=he.next;
      } while (he!=f.he);
      out.println();
    }
    out.flush();
  }

  float[] getExtents() {
    float[] extents=new float[]{1000000, 1000000, 1000000, -1000000, -1000000, -1000000};
    for (Vertex v : vertices) {
      extents[0]=min(v.x, extents[0]);
      extents[1]=min(v.y, extents[1]);
      extents[2]=min(v.z, extents[2]);
      extents[3]=max(v.x, extents[3]);
      extents[4]=max(v.y, extents[4]);
      extents[5]=max(v.z, extents[5]);
    }
    return extents;
  }


  void setFaceTextureIds(int[] textureIds) {
    int id=0;
    for (Face f : faces) {
      f.textureId=textureIds[id++];
    }
  }

  void setUVs(float[][] UVs) {
    int id=0;
    for (Halfedge he : halfedges) {
      he.UV=new PVector(UVs[id][0], UVs[id][1]);
      id++;
    }
  }
}

PShape getPShape(Mesh mesh) {
  if (mesh.isValid()) {
    PShape shape=createShape(GROUP);
    Halfedge he;
    for (Face f : mesh.faces) {
      PShape facet=createShape();
      facet.beginShape();
      he=f.he;
      do {
        facet.vertex(he.v.x, he.v.y, he.v.z);
        he=he.next;
      } while (he!=f.he);
      facet.endShape(CLOSE);
      shape.addChild(facet);
    }
    shape.disableStyle();
    return shape;
  } else {
    return createShape();
  }
}

static class MeshData {
  float[][] vertexArray;
  int[][] faceArray;
  int[] halfedgePairArray;
  color[] faceColor;
  int[] faceTextureIds;
  float[][] UVs;

  MeshData(float[][] vertexArray, int[][] faceArray, int[] halfedgePairArray, color[] faceColor) {
    this.vertexArray=vertexArray;
    this.faceArray=faceArray;
    this.halfedgePairArray=halfedgePairArray;
    this.faceColor=faceColor;
    this.faceTextureIds=null;
    this.UVs=null;
  }

  MeshData(float[][] vertexArray, int[][] faceArray, int[] halfedgePairArray, color[] faceColor, int[] faceTextureIds, float[][] UVs ) {
    this.vertexArray=vertexArray;
    this.faceArray=faceArray;
    this.halfedgePairArray=halfedgePairArray;
    this.faceColor=faceColor;
    this.faceTextureIds=faceTextureIds;
    this.UVs=UVs;
  }
}

static class MeshDataFactory {

  static MeshData createBoxWithCenterAndSize(float x, float y, float z, float width, float height, float depth, color col) {
    float[][] vertices=new float[][]{{-0.5, -0.5, -0.5}, {0.5, -0.5, -0.5}, {0.5, 0.5, -0.5}, {-0.5, 0.5, -0.5}, {-0.5, -0.5, 0.5}, {0.5, -0.5, 0.5}, {0.5, 0.5, 0.5}, {-0.5, 0.5, 0.5}};
    int[][] faces=new int[][]{{0, 1, 2, 3}, {7, 6, 5, 4}, {1, 0, 4, 5}, {3, 2, 6, 7}, {2, 1, 5, 6}, {0, 3, 7, 4}};
    int[] faceTextureIds=new int[]{1, 2, 3, 4, 5, 6};
    int[] halfedgePairs=new int[]{8, 16, 12, 20, 14, 18, 10, 22, 0, 23, 6, 17, 2, 19, 4, 21, 1, 11, 5, 13, 3, 15, 7, 9};
    float[][] UVs=new float[][]{{0, 0}, {1, 0}, {1, 1}, {0, 1}, {0, 0}, {1, 0}, {1, 1}, {0, 1}, {0, 0}, {1, 0}, {1, 1}, {0, 1}, {0, 0}, {1, 0}, {1, 1}, {0, 1}, {0, 0}, {1, 0}, {1, 1}, {0, 1}, {0, 0}, {1, 0}, {1, 1}, {0, 1}};
    float[][] scaledVertices=new float[vertices.length][3];
    for (int i=0; i<vertices.length; i++) {
      scaledVertices[i][0]=x+vertices[i][0]*width;
      scaledVertices[i][1]=y+vertices[i][1]*height;
      scaledVertices[i][2]=z+vertices[i][2]*depth;
    }
    return new MeshData(scaledVertices, faces, halfedgePairs, new color[]{col, col, col, col, col, col}, faceTextureIds, UVs);
  }

  static MeshData createBoxWithCornerAndSize(float x, float y, float z, float width, float height, float depth, color col) {
    float[][] vertices=new float[][]{{-0.5, -0.5, -0.5}, {0.5, -0.5, -0.5}, {0.5, 0.5, -0.5}, {-0.5, 0.5, -0.5}, {-0.5, -0.5, 0.5}, {0.5, -0.5, 0.5}, {0.5, 0.5, 0.5}, {-0.5, 0.5, 0.5}};
    int[][] faces=new int[][]{{0, 1, 2, 3}, {7, 6, 5, 4}, {1, 0, 4, 5}, {3, 2, 6, 7}, {2, 1, 5, 6}, {0, 3, 7, 4}};
    int[] faceTextureIds=new int[]{1, 2, 3, 4, 5, 6};
    int[] halfedgePairs=new int[]{8, 16, 12, 20, 14, 18, 10, 22, 0, 23, 6, 17, 2, 19, 4, 21, 1, 11, 5, 13, 3, 15, 7, 9};
    float[][] UVs=new float[][]{{0, 0}, {1, 0}, {1, 1}, {0, 1}, {0, 0}, {1, 0}, {1, 1}, {0, 1}, {0, 0}, {1, 0}, {1, 1}, {0, 1}, {0, 0}, {1, 0}, {1, 1}, {0, 1}, {0, 0}, {1, 0}, {1, 1}, {0, 1}, {0, 0}, {1, 0}, {1, 1}, {0, 1}};
    float[][] scaledVertices=new float[vertices.length][3];
    for (int i=0; i<vertices.length; i++) {
      scaledVertices[i][0]=x+(0.5+vertices[i][0])*width;
      scaledVertices[i][1]=y+(0.5+vertices[i][1])*height;
      scaledVertices[i][2]=z+(0.5+vertices[i][2])*depth;
    }
    return new MeshData(scaledVertices, faces, halfedgePairs, new color[]{col, col, col, col, col, col}, faceTextureIds, UVs);
  }

  static MeshData createOctahedronWithCenterAndSize(float x, float y, float z, float width, float height, float depth, color col) {
    float[][] vertices=new float[][]{{-0.5, 0, 0}, {0, 0.5, 0}, {0.5, 0, 0}, {0, -0.5, 0}, {0, 0, 0.5}, {0, 0, -0.5}};
    int[][] faces=new int[][]{{0, 1, 4}, {1, 2, 4}, {2, 3, 4}, {3, 0, 4}, {1, 0, 5}, {2, 1, 5}, {3, 2, 5}, {0, 3, 5}};
    int[] halfedgePairs=new int[]{12, 5, 10, 15, 8, 1, 18, 11, 4, 21, 2, 7, 0, 23, 16, 3, 14, 19, 6, 17, 22, 9, 20, 13};
    float[][] scaledVertices=new float[vertices.length][3];
    for (int i=0; i<vertices.length; i++) {
      scaledVertices[i][0]=x+vertices[i][0]*width;
      scaledVertices[i][1]=y+vertices[i][1]*height;
      scaledVertices[i][2]=z+vertices[i][2]*depth;
    }
    return new MeshData(scaledVertices, faces, halfedgePairs, new color[]{col, col, col, col, col, col, col, col});
  }


  static MeshData createPrismWithCenterRadiusAndHeight(int N, float x, float y, float z, float radius, float height, color col) {
    return createPrismWithCenterRadiusRangeAndHeight(N, x, y, z, radius, radius, height, col);
  }

  static MeshData createPrismWithCenterRadiusRangeAndHeight(int N, float x, float y, float z, float minRadius, float maxRadius, float height, color col) {
    float[][] vertices=new float[2*N][3];

    float radius;
    for (int i=0; i<N; i++) {
      radius=(float)Math.random()*(maxRadius- minRadius);
      vertices[i][0]=vertices[i+N][0]=cos(TWO_PI/N*i)*radius+x; 
      vertices[i][1]=vertices[i+N][1]=sin(TWO_PI/N*i)*radius+y;
      vertices[i][2]=-height/2+z;
      vertices[i+N][2]=height/2+z;
    }
    int[][] faces =new int[N+2][];
    color[] cols=new color[N+2];
    faces[0]=new int[N];
    faces[1]=new int[N];
    cols[0]=col;
    cols[1]=col;
    for (int i=0; i<N; i++) {
      faces[0][i]=N-1-i;
      faces[1][i]=N+i;
    }
    for (int i=0; i<N; i++) {
      faces[i+2]=new int[4];

      faces[i+2][0]=i;
      faces[i+2][1]=(i+1)%N;
      faces[i+2][2]=faces[i+2][1]+N;
      faces[i+2][3]=faces[i+2][0]+N;
      cols[i+2]=col;
    }
    return create(vertices, faces, cols);
  }

  static MeshData create(float[][] vertexArray, int[][] faceArray, int[] col) {
    int numberOfEdges=0;
    for (int[] face : faceArray) {
      numberOfEdges+=face.length;
    }
    int[] halfedgePairArray =new int[numberOfEdges];
    int[][] edges=new int[numberOfEdges][2];
    int index=0;
    for (int[] face : faceArray) {
      for (int i=0; i<face.length; i++) {
        edges[index][0]=face[i];
        edges[index][1]=face[(i+1)%face.length];
        halfedgePairArray[index]=-1;
        index++;
      }
    }
    for (int i=0; i<edges.length; i++) {
      if (halfedgePairArray[i]==-1) {
        for (int j=i+1; j<edges.length; j++) {
          if (edges[i][0]==edges[j][1] && edges[i][1]==edges[j][0]) {
            halfedgePairArray[i]=j;
            halfedgePairArray[j]=i;
          }
        }
      }
    }
    return new MeshData(vertexArray, faceArray, halfedgePairArray, col);
  }
}

class SliceMesh extends Mesh {
  SliceMesh() {
    super();
  }

  SliceMesh copy() {
    SliceMesh copy=new SliceMesh();
    copy.createRaw(copyVertexArray(), copyFaceArray(), copyHalfedgePairArray(), copyFaceColor());
     copy.setFaceTextureIds(copyFaceTextureIds());
    copy.setUVs(copyUVs());

    return copy;
  }
  
  void slice(Plane P, float offset, color col) {
    Plane offsetP=P.offset(offset);
    ArrayList<EdgeIntersection> intersections=new ArrayList<EdgeIntersection>();

    int es=edges.size();
    for (int i=0; i<es; i++) {
      sliceEdge(edges.get(i), offsetP, intersections);
    }

    int fs=faces.size();
    for (int i=0; i<fs; i++) {
      sliceFace(faces.get(i), intersections);
    }

    deleteFrontFaces(offsetP);
    capSlice(col,offsetP);

  }

  void sliceEdge(Edge e, Plane P, ArrayList<EdgeIntersection> intersections) {
    Halfedge he=e.he;
    Halfedge hep=he.pair;
    Vertex v=he.v;
    Vertex vp=hep.v;
    PVector u=new PVector(vp.x-v.x, vp.y-v.y, vp.z-v.z);
    PVector w=new PVector(v.x-P.origin.x, v.y-P.origin.y, v.z-P.origin.z);
    float D=P.normal.dot(u);
    float N=-P.normal.dot(w);
    if (abs(D)<EPS) {
      return;
    }
    float f=N/D;
    if (f<-EPS||f>OPEPS) {
      return;
    } else if (f<EPS) {
      intersections.add(new EdgeIntersection(e, v));
    } else if (f>OMEPS) {
      intersections.add(new EdgeIntersection(e, vp));
    } else {
      splitEdge(e, f);
      Vertex nv=vertices.get(vertices.size()-1);
      intersections.add(new EdgeIntersection(e, nv));
    }
  }

  void splitEdge(Edge e, float f) {
    Halfedge he=e.he;
    Halfedge hep=he.pair;
    Halfedge hen=he.next;
    Halfedge hepn=hep.next;
    Vertex v=he.v;
    Vertex vp=hep.v;
    createVertex((1.0-f)*v.x+f*vp.x, (1.0-f)*v.y+f*vp.y, (1.0-f)*v.z+f*vp.z);
    Vertex splitv=vertices.get(vertices.size()-1);
    Halfedge heNew=new Halfedge(halfedges.size());
    halfedges.add(heNew);
    connectVertex(splitv, heNew);
    connectFace(he.f, heNew);
    Halfedge hepNew=new Halfedge(halfedges.size());
    halfedges.add(hepNew);
    connectVertex(splitv, hepNew);
    connectFace(hep.f, hepNew);
    connectHalfedges(he, heNew);
    connectHalfedges(heNew, hen);
    heNew.UV=PVector.lerp(he.UV,hen.UV,f);
    connectHalfedges(hep, hepNew);
    connectHalfedges(hepNew, hepn);
    hepNew.UV=PVector.lerp(hep.UV,hepn.UV,1.0-f);
    pairHalfedges(he, hepNew);
    connectEdge(e, he);
    pairHalfedges(hep, heNew);
    createEdge(hep);
  }

  class EdgeIntersection {
    Edge e;
    Vertex v;

    EdgeIntersection(Edge e, Vertex v) {
      this.e=e;
      this.v=v;
    }
  }

  void sliceFace(Face f, ArrayList<EdgeIntersection> intersections) {
    Vertex vi=null;
    Vertex vj=null;
    for (EdgeIntersection ei : intersections) {
      if (ei.e.he.f==f || ei.e.he.pair.f==f) {
        if (vi==null) {
          vi=ei.v;
        } else 
        if (vi!=ei.v) {
          vj=ei.v;
          break;
        }
      }
    }
    if (vi!=null&&vj!=null) splitFace(f, vi.index, vj.index);
  }

  void splitFace(Face f, int i, int j) {
    Vertex vi=vertices.get(i);
    Halfedge hei=f.he;
    while (hei.v!=vi) {
      hei=hei.next; 
      if (hei==f.he) return;
    }
    Vertex vj=vertices.get(j);
    Halfedge hej=f.he;
    while (hej.v!=vj) {
      hej=hej.next; 
      if (hej==f.he) return;
    }
    if (hei.next==hej || hej.next==hei) return;
    Halfedge heip=hei.prev;
    Halfedge hejp=hej.prev;
    Halfedge heNew=new Halfedge(halfedges.size());
    Halfedge hepNew=new Halfedge(halfedges.size());
    heNew.UV=hej.UV.copy();
    hepNew.UV=hei.UV.copy();
    connectVertex(vi, hepNew);
    connectVertex(vj, heNew);
    pairHalfedges(heNew, hepNew);
    createEdge(heNew);
    halfedges.add(heNew);
    halfedges.add(hepNew);
    connectHalfedges(heip, hepNew);
    connectHalfedges(hepNew, hej);
    connectHalfedges(hejp, heNew);
    connectHalfedges(heNew, hei);
    heNew.f=f;
    Halfedge he=hej;
    Face nf=new Face(faces.size(), f.col);
    faces.add(nf);
    nf.textureId=f.textureId;
    do {
      connectFace(nf, he); 
      he=he.next;
    } while (he!=hej);
    f.he=hei;
  }

  void deleteFace(Face f) {
    Halfedge he=f.he;
    do {
      if (he.v.he==he) he.v.he=null;
      if (he.pair!=null) {
        he.pair.pair=null;
        he.pair.e=null;
      }
      halfedges.remove(he);
      edges.remove(he.e);
      he=he.next;
    } while (he!=f.he);  
    faces.remove(f);
    reconnectVertices();
    indexHalfedges();
    indexFaces();
    indexEdges();
    ArrayList<Vertex> checklist=new ArrayList<Vertex>();
    checklist.addAll(vertices);
    for (Vertex v : checklist) {
      if (v.he==null) vertices.remove(v);
    }
    indexVertices();
  }

  void deleteFrontFaces(Plane P) {
    ArrayList<Face> checklist=new ArrayList<Face>();
    checklist.addAll(faces);
    for (Face f : checklist) {
      if (f.sideOfPlane(P)==1) {
        deleteFace(f);
      }
    }
  }

  void capSlice(color col, Plane P) {
    Face cap=new Face(faces.size(), col);
    Halfedge caphe, trial;
    ArrayList<Halfedge> capHalfedges=new ArrayList<Halfedge>();
    for (Halfedge he : halfedges) {
      if (he.pair==null) {
        caphe=new Halfedge(halfedges.size()+capHalfedges.size()); 
        capHalfedges.add(caphe);
        pairHalfedges(he, caphe);
        createEdge(he);
        connectVertex(he.next.v, caphe);
        PVector local=P.local(caphe.v.x,caphe.v.y,caphe.v.z);
        caphe.UV=new PVector((local.x+400.0)/800.0,(local.y+400.0)/800.0);
        connectFace(cap, caphe);
        cap.textureId=7+currentSlice;
      }
    }
    halfedges.addAll(capHalfedges);
    if (capHalfedges.size()>0) faces.add(cap);
    for (int i=0; i<capHalfedges.size(); i++) {
      caphe=capHalfedges.get(i);
      if (caphe.next==null) {
        for (int j=0; j<capHalfedges.size(); j++) {
          trial=capHalfedges.get(j);
          if (i!=j && trial.v==caphe.pair.v) {
            connectHalfedges(caphe, trial);
            break;
          }
        }
      }
    }
  }

}

Transformation sliceAndRotate() {
  PVector origin;
  PVector normal; 
  int dirRoll=(int)random(3);
  float posRoll=random(-150, 150);
  switch(dirRoll) {
  case 0:
    origin=new PVector(posRoll, 0, 0);
    normal=new PVector(random(100)<50?1:-1, 0, 0);
    break;
  case 1:
    origin=new PVector(0, posRoll, 0);
    normal=new PVector(0, random(100)<50?1:-1, 0);
    break;
  default:
    origin=new PVector(0, 0, posRoll);
    normal=new PVector(0, 0, random(100)<50?1:-1);
  }
  float angle=radians(90);
  return new Transformation(origin, normal, angle, ROTATION);
}

Transformation sliceAndTranslate() {
  PVector origin;
  PVector normal; 
  PVector direction;
  float posRoll=random(-150, 150);
  int planeRoll=(int)random(6);
  switch(planeRoll) {
  case 0:
    origin=new PVector(posRoll, 0, 0);
    normal=new PVector(random(100)<50?1:-1, 0, 0);
    direction=new PVector(0, random(100)<50?1:-1, 0);
    break;
  case 1:
    origin=new PVector(0, posRoll, 0);
    normal=new PVector(0, random(100)<50?1:-1, 0);
    direction=new PVector(0, 0, random(100)<50?1:-1);
    break; 
  case 2:
    origin=new PVector(0, 0, posRoll);
    normal=new PVector(0, 0, random(100)<50?1:-1); 
    direction=new PVector(random(100)<50?1:-1, 0, 0);
    break;
  case 3:
    origin=new PVector(posRoll, 0, 0);
    normal=new PVector(random(100)<50?1:-1, 0, 0);
    direction=new PVector(0, 0, random(100)<50?1:-1);
    break;
  case 4:
    origin=new PVector(0, posRoll, 0);
    normal=new PVector(0, random(100)<50?1:-1, 0);
    direction=new PVector(random(100)<50?1:-1, 0, 0);
    break;
  default:
    origin=new PVector(0, 0, posRoll);
    normal=new PVector(0, 0, random(100)<50?1:-1); 
    direction=new PVector(0, random(100)<50?1:-1, 0);
    break;
  }
  float displacement =25.0*(int)random(1.0, 5.0);
  return new Transformation(origin, normal, displacement, direction, TRANSLATION);
}


Transformation sliceAndShear() {
  PVector origin;
  PVector normal; 
  PVector direction;
  float posRoll=random(-150, 150);
  int planeRoll=(int)random(6);
  switch(planeRoll) {
  case 0:
    origin=new PVector(posRoll, 0, 0);
    normal=new PVector(random(100)<50?1:-1, 0, 0);
    direction=new PVector(0, random(100)<50?1:-1, 0);
    break;
  case 1:
    origin=new PVector(0, posRoll, 0);
    normal=new PVector(0, random(100)<50?1:-1, 0);
    direction=new PVector(0, 0, random(100)<50?1:-1);
    break; 
  case 2:
    origin=new PVector(0, 0, posRoll);
    normal=new PVector(0, 0, random(100)<50?1:-1); 
    direction=new PVector(random(100)<50?1:-1, 0, 0);
    break;
  case 3:
    origin=new PVector(posRoll, 0, 0);
    normal=new PVector(random(100)<50?1:-1, 0, 0);
    direction=new PVector(0, 0, random(100)<50?1:-1);
    break;
  case 4:
    origin=new PVector(0, posRoll, 0);
    normal=new PVector(0, random(100)<50?1:-1, 0);
    direction=new PVector(random(100)<50?1:-1, 0, 0);
    break;
  default:
    origin=new PVector(0, 0, posRoll);
    normal=new PVector(0, 0, random(100)<50?1:-1); 
    direction=new PVector(0, random(100)<50?1:-1, 0);
    break;
  }
  float shearAngle =30;
  return new Transformation(origin, normal, shearAngle, direction, SHEAR);
}

Transformation sliceAndStretch() {
  PVector origin;
  PVector normal; 
  int dirRoll=(int)random(3);
  float posRoll=random(-150, 150);
  switch(dirRoll) {
  case 0:
    origin=new PVector(posRoll, 0, 0);
    normal=new PVector(random(100)<50?1:-1, 0, 0);
    break;
  case 1:
    origin=new PVector(0, posRoll, 0);
    normal=new PVector(0, random(100)<50?1:-1, 0);
    break;
  default:
    origin=new PVector(0, 0, posRoll);
    normal=new PVector(0, 0, random(100)<50?1:-1);
  }
  float  s =sqrt(2.0);
  s=(random(100)<50)?1.0/s:s;
  return new Transformation(origin, normal, s, STRETCH);
}




static int ROTATION=1;
static int TRANSLATION=0;
static int SHEAR=2;
static int STRETCH=3;

class Transformation {
  Transform T;
  Plane plane;
  PVector origin;
  PVector normal;
  PVector direction;
  PVector reverseDirection;
  float amount;
  int type;//0==translation, 1==rotation, 2==shear
  int level;

  //rotation or stretch
  Transformation(PVector origin, PVector axis, float angle, int type) {
    this.origin=origin.copy();
    this.normal=axis.copy();

    this.normal.normalize();
    this.plane = new Plane(this.origin, this.normal); 
    this.amount=angle; 
    this.type=type;
    assert(type==ROTATION|| type==STRETCH);
    this.direction=this.normal;
    this.reverseDirection=new PVector(-this.direction.x, -this.direction.y, -this.direction.z);
    this.level=0;
  }

  //translation or shear
  Transformation(PVector origin, PVector normal, float amount, PVector direction, int type) {
    this.origin=origin.copy();
    this.normal=normal.copy();
    this.normal.normalize();
    this.plane = new Plane(this.origin, this.normal); 
    this.type=type;
    assert(type==TRANSLATION || type==SHEAR);

    this.amount=amount; 
    this.direction =direction.copy();
    this.direction.normalize();
    this.reverseDirection=new PVector(-this.direction.x, -this.direction.y, -this.direction.z);
    this.level=0;
  }



  Transform getTransform(float f) {

    float fAmount=f*amount;
    T = new Transform(); 
    if (type==TRANSLATION) {
      T.addTranslate(fAmount, direction);
      T.addTranslate(f*(explode+level*explodePerLevel), normal);
    } else if (type==ROTATION) {
      T.addRotateAboutAxis(fAmount, origin, direction);
      T.addTranslate(f*(explode+level*explodePerLevel), normal);
    } else if (type==SHEAR) {
      T.addShear(origin, normal, direction, radians((float)fAmount));
      T.addTranslate(f*(explode+level*explodePerLevel), normal);
    } else if (type==STRETCH) {
      fAmount=1.0+f*(amount-1.0);
      T.addStretch(origin, normal, fAmount);
      T.addTranslate(f*(explode+level*explodePerLevel), normal);
    }
    return T;
  }

  Transform getInverseTransform(float f) {
    float fAmount=f*amount;
    T = new Transform(); 
    if (type==TRANSLATION) {
      T.addTranslate(-f*(explode+level*explodePerLevel), normal);
      T.addTranslate(fAmount, reverseDirection);
    } else if (type==ROTATION) {
      T.addTranslate(-f*(explode+level*explodePerLevel), normal);
      T.addRotateAboutAxis(fAmount, origin, reverseDirection);
    } else if (type==SHEAR) {
      T.addTranslate(-f*(explode+level*explodePerLevel), normal);
      T.addShear(origin, normal, reverseDirection, radians((float)fAmount));
    } else if (type==STRETCH) {
      fAmount=1.0+f*(amount-1.0);
      T.addTranslate(-f*(explode+level*explodePerLevel), normal);
      T.addStretch(origin, normal, 1.0/fAmount);
    }
    return T;
  }
}

    </script>
    <canvas id="sketch" style="border: 1px solid black;"></canvas>
    
  </body>
  
</html>
